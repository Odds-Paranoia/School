#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************   Forward Declarations    ********************/

class Program;
class GlobalDec;
class Literal;
class Type;
class Identifier;
class FormalParam;
class Block;
class Statement;
class FunctionInvocation;
class Primary;
class PostFixExpression;
class UnaryExpression;
class MultiplicativeExpression;
class AdditiveExpression;
class RelationalExpression;
class EqualityExpression;
class ConditionalAndExpression;
class ConditionalOrExpression;
class AssignmentExpression;
class Assignment;
class Expression;
class Prog;
class GFuncDec;
class GVFuncDec;
class GMainFuncDec;
class GVarDec;
class EInt;
class EString;
class ETrue;
class EFalse;
class TBool;
class TInt;
class EId;
class FParam;
class BBlock;
class SVarDec;
class SBlock;
class SEmpty;
class SAssign;
class SCall;
class SBreak;
class SRetExpr;
class SRet;
class SIfElse;
class SIf;
class SWhile;
class FCall;
class PLiteral;
class PExpr;
class PFuncInv;
class PFExprPrim;
class PFExprID;
class UnExpr;
class UnExprMin;
class UnExprNeg;
class MulExpr;
class MulExprMul;
class MulExprDiv;
class MulExprMod;
class AddExpr;
class AddExprAdd;
class AddExprSub;
class RelExpr;
class RelExprLT;
class RelExprGT;
class RelExprLE;
class RelExprGE;
class EqExpr;
class EqExprEQ;
class EqExprNE;
class CAExpr;
class CAExprAnd;
class COExpr;
class COExprOr;
class AssExpr;
class AssExprAss;
class Assign;
class Expr;
class ListStatement;
class ListGlobalDec;
class ListFormalParam;
class ListExpression;
class PIdentifier;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitProgram(Program *p) = 0;
  virtual void visitGlobalDec(GlobalDec *p) = 0;
  virtual void visitLiteral(Literal *p) = 0;
  virtual void visitType(Type *p) = 0;
  virtual void visitIdentifier(Identifier *p) = 0;
  virtual void visitFormalParam(FormalParam *p) = 0;
  virtual void visitBlock(Block *p) = 0;
  virtual void visitStatement(Statement *p) = 0;
  virtual void visitFunctionInvocation(FunctionInvocation *p) = 0;
  virtual void visitPrimary(Primary *p) = 0;
  virtual void visitPostFixExpression(PostFixExpression *p) = 0;
  virtual void visitUnaryExpression(UnaryExpression *p) = 0;
  virtual void visitMultiplicativeExpression(MultiplicativeExpression *p) = 0;
  virtual void visitAdditiveExpression(AdditiveExpression *p) = 0;
  virtual void visitRelationalExpression(RelationalExpression *p) = 0;
  virtual void visitEqualityExpression(EqualityExpression *p) = 0;
  virtual void visitConditionalAndExpression(ConditionalAndExpression *p) = 0;
  virtual void visitConditionalOrExpression(ConditionalOrExpression *p) = 0;
  virtual void visitAssignmentExpression(AssignmentExpression *p) = 0;
  virtual void visitAssignment(Assignment *p) = 0;
  virtual void visitExpression(Expression *p) = 0;
  virtual void visitProg(Prog *p) = 0;
  virtual void visitGFuncDec(GFuncDec *p) = 0;
  virtual void visitGVFuncDec(GVFuncDec *p) = 0;
  virtual void visitGMainFuncDec(GMainFuncDec *p) = 0;
  virtual void visitGVarDec(GVarDec *p) = 0;
  virtual void visitEInt(EInt *p) = 0;
  virtual void visitEString(EString *p) = 0;
  virtual void visitETrue(ETrue *p) = 0;
  virtual void visitEFalse(EFalse *p) = 0;
  virtual void visitTBool(TBool *p) = 0;
  virtual void visitTInt(TInt *p) = 0;
  virtual void visitEId(EId *p) = 0;
  virtual void visitFParam(FParam *p) = 0;
  virtual void visitBBlock(BBlock *p) = 0;
  virtual void visitSVarDec(SVarDec *p) = 0;
  virtual void visitSBlock(SBlock *p) = 0;
  virtual void visitSEmpty(SEmpty *p) = 0;
  virtual void visitSAssign(SAssign *p) = 0;
  virtual void visitSCall(SCall *p) = 0;
  virtual void visitSBreak(SBreak *p) = 0;
  virtual void visitSRetExpr(SRetExpr *p) = 0;
  virtual void visitSRet(SRet *p) = 0;
  virtual void visitSIfElse(SIfElse *p) = 0;
  virtual void visitSIf(SIf *p) = 0;
  virtual void visitSWhile(SWhile *p) = 0;
  virtual void visitFCall(FCall *p) = 0;
  virtual void visitPLiteral(PLiteral *p) = 0;
  virtual void visitPExpr(PExpr *p) = 0;
  virtual void visitPFuncInv(PFuncInv *p) = 0;
  virtual void visitPFExprPrim(PFExprPrim *p) = 0;
  virtual void visitPFExprID(PFExprID *p) = 0;
  virtual void visitUnExpr(UnExpr *p) = 0;
  virtual void visitUnExprMin(UnExprMin *p) = 0;
  virtual void visitUnExprNeg(UnExprNeg *p) = 0;
  virtual void visitMulExpr(MulExpr *p) = 0;
  virtual void visitMulExprMul(MulExprMul *p) = 0;
  virtual void visitMulExprDiv(MulExprDiv *p) = 0;
  virtual void visitMulExprMod(MulExprMod *p) = 0;
  virtual void visitAddExpr(AddExpr *p) = 0;
  virtual void visitAddExprAdd(AddExprAdd *p) = 0;
  virtual void visitAddExprSub(AddExprSub *p) = 0;
  virtual void visitRelExpr(RelExpr *p) = 0;
  virtual void visitRelExprLT(RelExprLT *p) = 0;
  virtual void visitRelExprGT(RelExprGT *p) = 0;
  virtual void visitRelExprLE(RelExprLE *p) = 0;
  virtual void visitRelExprGE(RelExprGE *p) = 0;
  virtual void visitEqExpr(EqExpr *p) = 0;
  virtual void visitEqExprEQ(EqExprEQ *p) = 0;
  virtual void visitEqExprNE(EqExprNE *p) = 0;
  virtual void visitCAExpr(CAExpr *p) = 0;
  virtual void visitCAExprAnd(CAExprAnd *p) = 0;
  virtual void visitCOExpr(COExpr *p) = 0;
  virtual void visitCOExprOr(COExprOr *p) = 0;
  virtual void visitAssExpr(AssExpr *p) = 0;
  virtual void visitAssExprAss(AssExprAss *p) = 0;
  virtual void visitAssign(Assign *p) = 0;
  virtual void visitExpr(Expr *p) = 0;
  virtual void visitListStatement(ListStatement *p) = 0;
  virtual void visitListGlobalDec(ListGlobalDec *p) = 0;
  virtual void visitListFormalParam(ListFormalParam *p) = 0;
  virtual void visitListExpression(ListExpression *p) = 0;
  virtual void visitPIdentifier(PIdentifier *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Program : public Visitable
{
public:
  virtual Program *clone() const = 0;

};

class GlobalDec : public Visitable
{
public:
  virtual GlobalDec *clone() const = 0;

};

class Literal : public Visitable
{
public:
  virtual Literal *clone() const = 0;

};

class Type : public Visitable
{
public:
  virtual Type *clone() const = 0;

};

class Identifier : public Visitable
{
public:
  virtual Identifier *clone() const = 0;

};

class FormalParam : public Visitable
{
public:
  virtual FormalParam *clone() const = 0;

};

class Block : public Visitable
{
public:
  virtual Block *clone() const = 0;

};

class Statement : public Visitable
{
public:
  virtual Statement *clone() const = 0;

};

class FunctionInvocation : public Visitable
{
public:
  virtual FunctionInvocation *clone() const = 0;

};

class Primary : public Visitable
{
public:
  virtual Primary *clone() const = 0;

};

class PostFixExpression : public Visitable
{
public:
  virtual PostFixExpression *clone() const = 0;

};

class UnaryExpression : public Visitable
{
public:
  virtual UnaryExpression *clone() const = 0;

};

class MultiplicativeExpression : public Visitable
{
public:
  virtual MultiplicativeExpression *clone() const = 0;

};

class AdditiveExpression : public Visitable
{
public:
  virtual AdditiveExpression *clone() const = 0;

};

class RelationalExpression : public Visitable
{
public:
  virtual RelationalExpression *clone() const = 0;

};

class EqualityExpression : public Visitable
{
public:
  virtual EqualityExpression *clone() const = 0;

};

class ConditionalAndExpression : public Visitable
{
public:
  virtual ConditionalAndExpression *clone() const = 0;

};

class ConditionalOrExpression : public Visitable
{
public:
  virtual ConditionalOrExpression *clone() const = 0;

};

class AssignmentExpression : public Visitable
{
public:
  virtual AssignmentExpression *clone() const = 0;

};

class Assignment : public Visitable
{
public:
  virtual Assignment *clone() const = 0;

};

class Expression : public Visitable
{
public:
  virtual Expression *clone() const = 0;

};



class PIdentifier : public Visitable
{
public:
  String string_;
  Integer integer_;

  PIdentifier(const PIdentifier &);
  PIdentifier &operator=(const PIdentifier &);
  PIdentifier(String p1, Integer p2);
  ~PIdentifier();
  String sko_getName();
  virtual void accept(Visitor *v);
  virtual PIdentifier *clone() const;
  void swap(PIdentifier &);
};

class Prog : public Program
{
public:
  ListGlobalDec *listglobaldec_;

  Prog(const Prog &);
  Prog &operator=(const Prog &);
  Prog(ListGlobalDec *p1);
  ~Prog();
  virtual void accept(Visitor *v);
  virtual Prog *clone() const;
  void swap(Prog &);
};

class GFuncDec : public GlobalDec
{
public:
  Type *type_;
  Identifier *identifier_;
  ListFormalParam *listformalparam_;
  Block *block_;

  GFuncDec(const GFuncDec &);
  GFuncDec &operator=(const GFuncDec &);
  GFuncDec(Type *p1, Identifier *p2, ListFormalParam *p3, Block *p4);
  ~GFuncDec();
  virtual void accept(Visitor *v);
  virtual GFuncDec *clone() const;
  void swap(GFuncDec &);
};

class GVFuncDec : public GlobalDec
{
public:
  Identifier *identifier_;
  ListFormalParam *listformalparam_;
  Block *block_;

  GVFuncDec(const GVFuncDec &);
  GVFuncDec &operator=(const GVFuncDec &);
  GVFuncDec(Identifier *p1, ListFormalParam *p2, Block *p3);
  ~GVFuncDec();
  virtual void accept(Visitor *v);
  virtual GVFuncDec *clone() const;
  void swap(GVFuncDec &);
};

class GMainFuncDec : public GlobalDec
{
public:
  Identifier *identifier_;
  ListStatement *liststatement_;

  GMainFuncDec(const GMainFuncDec &);
  GMainFuncDec &operator=(const GMainFuncDec &);
  GMainFuncDec(Identifier *p1, ListStatement *p2);
  ~GMainFuncDec();
  virtual void accept(Visitor *v);
  virtual GMainFuncDec *clone() const;
  void swap(GMainFuncDec &);
};

class GVarDec : public GlobalDec
{
public:
  Type *type_;
  Identifier *identifier_;

  GVarDec(const GVarDec &);
  GVarDec &operator=(const GVarDec &);
  GVarDec(Type *p1, Identifier *p2);
  ~GVarDec();
  virtual void accept(Visitor *v);
  virtual GVarDec *clone() const;
  void swap(GVarDec &);
};

class EInt : public Literal
{
public:
  Integer integer_;

  EInt(const EInt &);
  EInt &operator=(const EInt &);
  EInt(Integer p1);
  ~EInt();
  virtual void accept(Visitor *v);
  virtual EInt *clone() const;
  void swap(EInt &);
};

class EString : public Literal
{
public:
  String string_;

  EString(const EString &);
  EString &operator=(const EString &);
  EString(String p1);
  ~EString();
  virtual void accept(Visitor *v);
  virtual EString *clone() const;
  void swap(EString &);
};

class ETrue : public Literal
{
public:

  ETrue(const ETrue &);
  ETrue &operator=(const ETrue &);
  ETrue();
  ~ETrue();
  virtual void accept(Visitor *v);
  virtual ETrue *clone() const;
  void swap(ETrue &);
};

class EFalse : public Literal
{
public:

  EFalse(const EFalse &);
  EFalse &operator=(const EFalse &);
  EFalse();
  ~EFalse();
  virtual void accept(Visitor *v);
  virtual EFalse *clone() const;
  void swap(EFalse &);
};

class TBool : public Type
{
public:

  TBool(const TBool &);
  TBool &operator=(const TBool &);
  TBool();
  ~TBool();
  virtual void accept(Visitor *v);
  virtual TBool *clone() const;
  void swap(TBool &);
};

class TInt : public Type
{
public:

  TInt(const TInt &);
  TInt &operator=(const TInt &);
  TInt();
  ~TInt();
  virtual void accept(Visitor *v);
  virtual TInt *clone() const;
  void swap(TInt &);
};

class EId : public Identifier
{
public:
  PIdentifier *pidentifier_;

  EId(const EId &);
  EId &operator=(const EId &);
  EId(PIdentifier *p1);
  ~EId();
  virtual void accept(Visitor *v);
  virtual EId *clone() const;
  void swap(EId &);
};

class FParam : public FormalParam
{
public:
  Type *type_;
  Identifier *identifier_;

  FParam(const FParam &);
  FParam &operator=(const FParam &);
  FParam(Type *p1, Identifier *p2);
  ~FParam();
  virtual void accept(Visitor *v);
  virtual FParam *clone() const;
  void swap(FParam &);
};

class BBlock : public Block
{
public:
  ListStatement *liststatement_;

  BBlock(const BBlock &);
  BBlock &operator=(const BBlock &);
  BBlock(ListStatement *p1);
  ~BBlock();
  virtual void accept(Visitor *v);
  virtual BBlock *clone() const;
  void swap(BBlock &);
};

class SVarDec : public Statement
{
public:
  Type *type_;
  Identifier *identifier_;

  SVarDec(const SVarDec &);
  SVarDec &operator=(const SVarDec &);
  SVarDec(Type *p1, Identifier *p2);
  ~SVarDec();
  virtual void accept(Visitor *v);
  virtual SVarDec *clone() const;
  void swap(SVarDec &);
};

class SBlock : public Statement
{
public:
  Block *block_;

  SBlock(const SBlock &);
  SBlock &operator=(const SBlock &);
  SBlock(Block *p1);
  ~SBlock();
  virtual void accept(Visitor *v);
  virtual SBlock *clone() const;
  void swap(SBlock &);
};

class SEmpty : public Statement
{
public:

  SEmpty(const SEmpty &);
  SEmpty &operator=(const SEmpty &);
  SEmpty();
  ~SEmpty();
  virtual void accept(Visitor *v);
  virtual SEmpty *clone() const;
  void swap(SEmpty &);
};

class SAssign : public Statement
{
public:
  Assignment *assignment_;

  SAssign(const SAssign &);
  SAssign &operator=(const SAssign &);
  SAssign(Assignment *p1);
  ~SAssign();
  virtual void accept(Visitor *v);
  virtual SAssign *clone() const;
  void swap(SAssign &);
};

class SCall : public Statement
{
public:
  FunctionInvocation *functioninvocation_;

  SCall(const SCall &);
  SCall &operator=(const SCall &);
  SCall(FunctionInvocation *p1);
  ~SCall();
  virtual void accept(Visitor *v);
  virtual SCall *clone() const;
  void swap(SCall &);
};

class SBreak : public Statement
{
public:

  SBreak(const SBreak &);
  SBreak &operator=(const SBreak &);
  SBreak();
  ~SBreak();
  virtual void accept(Visitor *v);
  virtual SBreak *clone() const;
  void swap(SBreak &);
};

class SRetExpr : public Statement
{
public:
  Expression *expression_;

  SRetExpr(const SRetExpr &);
  SRetExpr &operator=(const SRetExpr &);
  SRetExpr(Expression *p1);
  ~SRetExpr();
  virtual void accept(Visitor *v);
  virtual SRetExpr *clone() const;
  void swap(SRetExpr &);
};

class SRet : public Statement
{
public:

  SRet(const SRet &);
  SRet &operator=(const SRet &);
  SRet();
  ~SRet();
  virtual void accept(Visitor *v);
  virtual SRet *clone() const;
  void swap(SRet &);
};

class SIfElse : public Statement
{
public:
  Expression *expression_;
  Statement *statement_1;
  Statement *statement_2;

  SIfElse(const SIfElse &);
  SIfElse &operator=(const SIfElse &);
  SIfElse(Expression *p1, Statement *p2, Statement *p3);
  ~SIfElse();
  virtual void accept(Visitor *v);
  virtual SIfElse *clone() const;
  void swap(SIfElse &);
};

class SIf : public Statement
{
public:
  Expression *expression_;
  Statement *statement_;

  SIf(const SIf &);
  SIf &operator=(const SIf &);
  SIf(Expression *p1, Statement *p2);
  ~SIf();
  virtual void accept(Visitor *v);
  virtual SIf *clone() const;
  void swap(SIf &);
};

class SWhile : public Statement
{
public:
  Expression *expression_;
  Statement *statement_;

  SWhile(const SWhile &);
  SWhile &operator=(const SWhile &);
  SWhile(Expression *p1, Statement *p2);
  ~SWhile();
  virtual void accept(Visitor *v);
  virtual SWhile *clone() const;
  void swap(SWhile &);
};

class FCall : public FunctionInvocation
{
public:
  Identifier *identifier_;
  ListExpression *listexpression_;

  FCall(const FCall &);
  FCall &operator=(const FCall &);
  FCall(Identifier *p1, ListExpression *p2);
  ~FCall();
  virtual void accept(Visitor *v);
  virtual FCall *clone() const;
  void swap(FCall &);
};

class PLiteral : public Primary
{
public:
  Literal *literal_;

  PLiteral(const PLiteral &);
  PLiteral &operator=(const PLiteral &);
  PLiteral(Literal *p1);
  ~PLiteral();
  virtual void accept(Visitor *v);
  virtual PLiteral *clone() const;
  void swap(PLiteral &);
};

class PExpr : public Primary
{
public:
  Expression *expression_;

  PExpr(const PExpr &);
  PExpr &operator=(const PExpr &);
  PExpr(Expression *p1);
  ~PExpr();
  virtual void accept(Visitor *v);
  virtual PExpr *clone() const;
  void swap(PExpr &);
};

class PFuncInv : public Primary
{
public:
  FunctionInvocation *functioninvocation_;

  PFuncInv(const PFuncInv &);
  PFuncInv &operator=(const PFuncInv &);
  PFuncInv(FunctionInvocation *p1);
  ~PFuncInv();
  virtual void accept(Visitor *v);
  virtual PFuncInv *clone() const;
  void swap(PFuncInv &);
};

class PFExprPrim : public PostFixExpression
{
public:
  Primary *primary_;

  PFExprPrim(const PFExprPrim &);
  PFExprPrim &operator=(const PFExprPrim &);
  PFExprPrim(Primary *p1);
  ~PFExprPrim();
  virtual void accept(Visitor *v);
  virtual PFExprPrim *clone() const;
  void swap(PFExprPrim &);
};

class PFExprID : public PostFixExpression
{
public:
  Identifier *identifier_;

  PFExprID(const PFExprID &);
  PFExprID &operator=(const PFExprID &);
  PFExprID(Identifier *p1);
  ~PFExprID();
  virtual void accept(Visitor *v);
  virtual PFExprID *clone() const;
  void swap(PFExprID &);
};

class UnExpr : public UnaryExpression
{
public:
  PostFixExpression *postfixexpression_;

  UnExpr(const UnExpr &);
  UnExpr &operator=(const UnExpr &);
  UnExpr(PostFixExpression *p1);
  ~UnExpr();
  virtual void accept(Visitor *v);
  virtual UnExpr *clone() const;
  void swap(UnExpr &);
};

class UnExprMin : public UnaryExpression
{
public:
  UnaryExpression *unaryexpression_;

  UnExprMin(const UnExprMin &);
  UnExprMin &operator=(const UnExprMin &);
  UnExprMin(UnaryExpression *p1);
  ~UnExprMin();
  virtual void accept(Visitor *v);
  virtual UnExprMin *clone() const;
  void swap(UnExprMin &);
};

class UnExprNeg : public UnaryExpression
{
public:
  UnaryExpression *unaryexpression_;

  UnExprNeg(const UnExprNeg &);
  UnExprNeg &operator=(const UnExprNeg &);
  UnExprNeg(UnaryExpression *p1);
  ~UnExprNeg();
  virtual void accept(Visitor *v);
  virtual UnExprNeg *clone() const;
  void swap(UnExprNeg &);
};

class MulExpr : public MultiplicativeExpression
{
public:
  UnaryExpression *unaryexpression_;

  MulExpr(const MulExpr &);
  MulExpr &operator=(const MulExpr &);
  MulExpr(UnaryExpression *p1);
  ~MulExpr();
  virtual void accept(Visitor *v);
  virtual MulExpr *clone() const;
  void swap(MulExpr &);
};

class MulExprMul : public MultiplicativeExpression
{
public:
  MultiplicativeExpression *multiplicativeexpression_;
  UnaryExpression *unaryexpression_;

  MulExprMul(const MulExprMul &);
  MulExprMul &operator=(const MulExprMul &);
  MulExprMul(MultiplicativeExpression *p1, UnaryExpression *p2);
  ~MulExprMul();
  virtual void accept(Visitor *v);
  virtual MulExprMul *clone() const;
  void swap(MulExprMul &);
};

class MulExprDiv : public MultiplicativeExpression
{
public:
  MultiplicativeExpression *multiplicativeexpression_;
  UnaryExpression *unaryexpression_;

  MulExprDiv(const MulExprDiv &);
  MulExprDiv &operator=(const MulExprDiv &);
  MulExprDiv(MultiplicativeExpression *p1, UnaryExpression *p2);
  ~MulExprDiv();
  virtual void accept(Visitor *v);
  virtual MulExprDiv *clone() const;
  void swap(MulExprDiv &);
};

class MulExprMod : public MultiplicativeExpression
{
public:
  MultiplicativeExpression *multiplicativeexpression_;
  UnaryExpression *unaryexpression_;

  MulExprMod(const MulExprMod &);
  MulExprMod &operator=(const MulExprMod &);
  MulExprMod(MultiplicativeExpression *p1, UnaryExpression *p2);
  ~MulExprMod();
  virtual void accept(Visitor *v);
  virtual MulExprMod *clone() const;
  void swap(MulExprMod &);
};

class AddExpr : public AdditiveExpression
{
public:
  MultiplicativeExpression *multiplicativeexpression_;

  AddExpr(const AddExpr &);
  AddExpr &operator=(const AddExpr &);
  AddExpr(MultiplicativeExpression *p1);
  ~AddExpr();
  virtual void accept(Visitor *v);
  virtual AddExpr *clone() const;
  void swap(AddExpr &);
};

class AddExprAdd : public AdditiveExpression
{
public:
  AdditiveExpression *additiveexpression_;
  MultiplicativeExpression *multiplicativeexpression_;

  AddExprAdd(const AddExprAdd &);
  AddExprAdd &operator=(const AddExprAdd &);
  AddExprAdd(AdditiveExpression *p1, MultiplicativeExpression *p2);
  ~AddExprAdd();
  virtual void accept(Visitor *v);
  virtual AddExprAdd *clone() const;
  void swap(AddExprAdd &);
};

class AddExprSub : public AdditiveExpression
{
public:
  AdditiveExpression *additiveexpression_;
  MultiplicativeExpression *multiplicativeexpression_;

  AddExprSub(const AddExprSub &);
  AddExprSub &operator=(const AddExprSub &);
  AddExprSub(AdditiveExpression *p1, MultiplicativeExpression *p2);
  ~AddExprSub();
  virtual void accept(Visitor *v);
  virtual AddExprSub *clone() const;
  void swap(AddExprSub &);
};

class RelExpr : public RelationalExpression
{
public:
  AdditiveExpression *additiveexpression_;

  RelExpr(const RelExpr &);
  RelExpr &operator=(const RelExpr &);
  RelExpr(AdditiveExpression *p1);
  ~RelExpr();
  virtual void accept(Visitor *v);
  virtual RelExpr *clone() const;
  void swap(RelExpr &);
};

class RelExprLT : public RelationalExpression
{
public:
  RelationalExpression *relationalexpression_;
  AdditiveExpression *additiveexpression_;

  RelExprLT(const RelExprLT &);
  RelExprLT &operator=(const RelExprLT &);
  RelExprLT(RelationalExpression *p1, AdditiveExpression *p2);
  ~RelExprLT();
  virtual void accept(Visitor *v);
  virtual RelExprLT *clone() const;
  void swap(RelExprLT &);
};

class RelExprGT : public RelationalExpression
{
public:
  RelationalExpression *relationalexpression_;
  AdditiveExpression *additiveexpression_;

  RelExprGT(const RelExprGT &);
  RelExprGT &operator=(const RelExprGT &);
  RelExprGT(RelationalExpression *p1, AdditiveExpression *p2);
  ~RelExprGT();
  virtual void accept(Visitor *v);
  virtual RelExprGT *clone() const;
  void swap(RelExprGT &);
};

class RelExprLE : public RelationalExpression
{
public:
  RelationalExpression *relationalexpression_;
  AdditiveExpression *additiveexpression_;

  RelExprLE(const RelExprLE &);
  RelExprLE &operator=(const RelExprLE &);
  RelExprLE(RelationalExpression *p1, AdditiveExpression *p2);
  ~RelExprLE();
  virtual void accept(Visitor *v);
  virtual RelExprLE *clone() const;
  void swap(RelExprLE &);
};

class RelExprGE : public RelationalExpression
{
public:
  RelationalExpression *relationalexpression_;
  AdditiveExpression *additiveexpression_;

  RelExprGE(const RelExprGE &);
  RelExprGE &operator=(const RelExprGE &);
  RelExprGE(RelationalExpression *p1, AdditiveExpression *p2);
  ~RelExprGE();
  virtual void accept(Visitor *v);
  virtual RelExprGE *clone() const;
  void swap(RelExprGE &);
};

class EqExpr : public EqualityExpression
{
public:
  RelationalExpression *relationalexpression_;

  EqExpr(const EqExpr &);
  EqExpr &operator=(const EqExpr &);
  EqExpr(RelationalExpression *p1);
  ~EqExpr();
  virtual void accept(Visitor *v);
  virtual EqExpr *clone() const;
  void swap(EqExpr &);
};

class EqExprEQ : public EqualityExpression
{
public:
  EqualityExpression *equalityexpression_;
  RelationalExpression *relationalexpression_;

  EqExprEQ(const EqExprEQ &);
  EqExprEQ &operator=(const EqExprEQ &);
  EqExprEQ(EqualityExpression *p1, RelationalExpression *p2);
  ~EqExprEQ();
  virtual void accept(Visitor *v);
  virtual EqExprEQ *clone() const;
  void swap(EqExprEQ &);
};

class EqExprNE : public EqualityExpression
{
public:
  EqualityExpression *equalityexpression_;
  RelationalExpression *relationalexpression_;

  EqExprNE(const EqExprNE &);
  EqExprNE &operator=(const EqExprNE &);
  EqExprNE(EqualityExpression *p1, RelationalExpression *p2);
  ~EqExprNE();
  virtual void accept(Visitor *v);
  virtual EqExprNE *clone() const;
  void swap(EqExprNE &);
};

class CAExpr : public ConditionalAndExpression
{
public:
  EqualityExpression *equalityexpression_;

  CAExpr(const CAExpr &);
  CAExpr &operator=(const CAExpr &);
  CAExpr(EqualityExpression *p1);
  ~CAExpr();
  virtual void accept(Visitor *v);
  virtual CAExpr *clone() const;
  void swap(CAExpr &);
};

class CAExprAnd : public ConditionalAndExpression
{
public:
  ConditionalAndExpression *conditionalandexpression_;
  EqualityExpression *equalityexpression_;

  CAExprAnd(const CAExprAnd &);
  CAExprAnd &operator=(const CAExprAnd &);
  CAExprAnd(ConditionalAndExpression *p1, EqualityExpression *p2);
  ~CAExprAnd();
  virtual void accept(Visitor *v);
  virtual CAExprAnd *clone() const;
  void swap(CAExprAnd &);
};

class COExpr : public ConditionalOrExpression
{
public:
  ConditionalAndExpression *conditionalandexpression_;

  COExpr(const COExpr &);
  COExpr &operator=(const COExpr &);
  COExpr(ConditionalAndExpression *p1);
  ~COExpr();
  virtual void accept(Visitor *v);
  virtual COExpr *clone() const;
  void swap(COExpr &);
};

class COExprOr : public ConditionalOrExpression
{
public:
  ConditionalOrExpression *conditionalorexpression_;
  ConditionalAndExpression *conditionalandexpression_;

  COExprOr(const COExprOr &);
  COExprOr &operator=(const COExprOr &);
  COExprOr(ConditionalOrExpression *p1, ConditionalAndExpression *p2);
  ~COExprOr();
  virtual void accept(Visitor *v);
  virtual COExprOr *clone() const;
  void swap(COExprOr &);
};

class AssExpr : public AssignmentExpression
{
public:
  ConditionalOrExpression *conditionalorexpression_;

  AssExpr(const AssExpr &);
  AssExpr &operator=(const AssExpr &);
  AssExpr(ConditionalOrExpression *p1);
  ~AssExpr();
  virtual void accept(Visitor *v);
  virtual AssExpr *clone() const;
  void swap(AssExpr &);
};

class AssExprAss : public AssignmentExpression
{
public:
  Assignment *assignment_;

  AssExprAss(const AssExprAss &);
  AssExprAss &operator=(const AssExprAss &);
  AssExprAss(Assignment *p1);
  ~AssExprAss();
  virtual void accept(Visitor *v);
  virtual AssExprAss *clone() const;
  void swap(AssExprAss &);
};

class Assign : public Assignment
{
public:
  Identifier *identifier_;
  AssignmentExpression *assignmentexpression_;

  Assign(const Assign &);
  Assign &operator=(const Assign &);
  Assign(Identifier *p1, AssignmentExpression *p2);
  ~Assign();
  virtual void accept(Visitor *v);
  virtual Assign *clone() const;
  void swap(Assign &);
};

class Expr : public Expression
{
public:
  AssignmentExpression *assignmentexpression_;

  Expr(const Expr &);
  Expr &operator=(const Expr &);
  Expr(AssignmentExpression *p1);
  ~Expr();
  virtual void accept(Visitor *v);
  virtual Expr *clone() const;
  void swap(Expr &);
};



class ListStatement : public Visitable, public std::vector<Statement*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListStatement *clone() const;
};

class ListGlobalDec : public Visitable, public std::vector<GlobalDec*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListGlobalDec *clone() const;
};

class ListFormalParam : public Visitable, public std::vector<FormalParam*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListFormalParam *clone() const;
};

class ListExpression : public Visitable, public std::vector<Expression*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExpression *clone() const;
};



#endif
