//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"

/********************   PIdentifier    ********************/
PIdentifier::PIdentifier(String p1, Integer p2)
{
  string_ = p1;
  integer_ = p2;
}

String PIdentifier::sko_getName()
{
  return this->string_;
}

PIdentifier::PIdentifier(const PIdentifier & other)
{
  string_ = other.string_;
  integer_ = other.integer_;
}

PIdentifier &PIdentifier::operator=(const PIdentifier & other)
{
  PIdentifier tmp(other);
  swap(tmp);
  return *this;
}

void PIdentifier::swap(PIdentifier & other)
{
  std::swap(string_, other.string_);
  std::swap(integer_, other.integer_);

}

PIdentifier::~PIdentifier()
{

}

void PIdentifier::accept(Visitor *v)
{
  v->visitPIdentifier(this);
}

PIdentifier *PIdentifier::clone() const
{
  return new PIdentifier(*this);
}



/********************   Prog    ********************/
Prog::Prog(ListGlobalDec *p1)
{
  listglobaldec_ = p1;

}

Prog::Prog(const Prog & other)
{
  listglobaldec_ = other.listglobaldec_->clone();

}

Prog &Prog::operator=(const Prog & other)
{
  Prog tmp(other);
  swap(tmp);
  return *this;
}

void Prog::swap(Prog & other)
{
  std::swap(listglobaldec_, other.listglobaldec_);

}

Prog::~Prog()
{
  delete(listglobaldec_);

}

void Prog::accept(Visitor *v)
{
  v->visitProg(this);
}

Prog *Prog::clone() const
{
  return new Prog(*this);
}



/********************   GFuncDec    ********************/
GFuncDec::GFuncDec(Type *p1, Identifier *p2, ListFormalParam *p3, Block *p4)
{
  type_ = p1;
  identifier_ = p2;
  listformalparam_ = p3;
  block_ = p4;

}

GFuncDec::GFuncDec(const GFuncDec & other)
{
  type_ = other.type_->clone();
  identifier_ = other.identifier_->clone();
  listformalparam_ = other.listformalparam_->clone();
  block_ = other.block_->clone();

}

GFuncDec &GFuncDec::operator=(const GFuncDec & other)
{
  GFuncDec tmp(other);
  swap(tmp);
  return *this;
}

void GFuncDec::swap(GFuncDec & other)
{
  std::swap(type_, other.type_);
  std::swap(identifier_, other.identifier_);
  std::swap(listformalparam_, other.listformalparam_);
  std::swap(block_, other.block_);

}

GFuncDec::~GFuncDec()
{
  delete(type_);
  delete(identifier_);
  delete(listformalparam_);
  delete(block_);

}

void GFuncDec::accept(Visitor *v)
{
  v->visitGFuncDec(this);
}

GFuncDec *GFuncDec::clone() const
{
  return new GFuncDec(*this);
}



/********************   GVFuncDec    ********************/
GVFuncDec::GVFuncDec(Identifier *p1, ListFormalParam *p2, Block *p3)
{
  identifier_ = p1;
  listformalparam_ = p2;
  block_ = p3;

}

GVFuncDec::GVFuncDec(const GVFuncDec & other)
{
  identifier_ = other.identifier_->clone();
  listformalparam_ = other.listformalparam_->clone();
  block_ = other.block_->clone();

}

GVFuncDec &GVFuncDec::operator=(const GVFuncDec & other)
{
  GVFuncDec tmp(other);
  swap(tmp);
  return *this;
}

void GVFuncDec::swap(GVFuncDec & other)
{
  std::swap(identifier_, other.identifier_);
  std::swap(listformalparam_, other.listformalparam_);
  std::swap(block_, other.block_);

}

GVFuncDec::~GVFuncDec()
{
  delete(identifier_);
  delete(listformalparam_);
  delete(block_);

}

void GVFuncDec::accept(Visitor *v)
{
  v->visitGVFuncDec(this);
}

GVFuncDec *GVFuncDec::clone() const
{
  return new GVFuncDec(*this);
}



/********************   GMainFuncDec    ********************/
GMainFuncDec::GMainFuncDec(Identifier *p1, ListStatement *p2)
{
  identifier_ = p1;
  liststatement_ = p2;

}

GMainFuncDec::GMainFuncDec(const GMainFuncDec & other)
{
  identifier_ = other.identifier_->clone();
  liststatement_ = other.liststatement_->clone();

}

GMainFuncDec &GMainFuncDec::operator=(const GMainFuncDec & other)
{
  GMainFuncDec tmp(other);
  swap(tmp);
  return *this;
}

void GMainFuncDec::swap(GMainFuncDec & other)
{
  std::swap(identifier_, other.identifier_);
  std::swap(liststatement_, other.liststatement_);

}

GMainFuncDec::~GMainFuncDec()
{
  delete(identifier_);
  delete(liststatement_);

}

void GMainFuncDec::accept(Visitor *v)
{
  v->visitGMainFuncDec(this);
}

GMainFuncDec *GMainFuncDec::clone() const
{
  return new GMainFuncDec(*this);
}



/********************   GVarDec    ********************/
GVarDec::GVarDec(Type *p1, Identifier *p2)
{
  type_ = p1;
  identifier_ = p2;

}

GVarDec::GVarDec(const GVarDec & other)
{
  type_ = other.type_->clone();
  identifier_ = other.identifier_->clone();

}

GVarDec &GVarDec::operator=(const GVarDec & other)
{
  GVarDec tmp(other);
  swap(tmp);
  return *this;
}

void GVarDec::swap(GVarDec & other)
{
  std::swap(type_, other.type_);
  std::swap(identifier_, other.identifier_);

}

GVarDec::~GVarDec()
{
  delete(type_);
  delete(identifier_);

}

void GVarDec::accept(Visitor *v)
{
  v->visitGVarDec(this);
}

GVarDec *GVarDec::clone() const
{
  return new GVarDec(*this);
}



/********************   EInt    ********************/
EInt::EInt(Integer p1)
{
  integer_ = p1;

}

EInt::EInt(const EInt & other)
{
  integer_ = other.integer_;

}

EInt &EInt::operator=(const EInt & other)
{
  EInt tmp(other);
  swap(tmp);
  return *this;
}

void EInt::swap(EInt & other)
{
  std::swap(integer_, other.integer_);

}

EInt::~EInt()
{

}

void EInt::accept(Visitor *v)
{
  v->visitEInt(this);
}

EInt *EInt::clone() const
{
  return new EInt(*this);
}



/********************   EString    ********************/
EString::EString(String p1)
{
  string_ = p1;

}

EString::EString(const EString & other)
{
  string_ = other.string_;

}

EString &EString::operator=(const EString & other)
{
  EString tmp(other);
  swap(tmp);
  return *this;
}

void EString::swap(EString & other)
{
  std::swap(string_, other.string_);

}

EString::~EString()
{

}

void EString::accept(Visitor *v)
{
  v->visitEString(this);
}

EString *EString::clone() const
{
  return new EString(*this);
}



/********************   ETrue    ********************/
ETrue::ETrue()
{

}

ETrue::ETrue(const ETrue & other)
{

}

ETrue &ETrue::operator=(const ETrue & other)
{
  ETrue tmp(other);
  swap(tmp);
  return *this;
}

void ETrue::swap(ETrue & other)
{

}

ETrue::~ETrue()
{

}

void ETrue::accept(Visitor *v)
{
  v->visitETrue(this);
}

ETrue *ETrue::clone() const
{
  return new ETrue(*this);
}



/********************   EFalse    ********************/
EFalse::EFalse()
{

}

EFalse::EFalse(const EFalse & other)
{

}

EFalse &EFalse::operator=(const EFalse & other)
{
  EFalse tmp(other);
  swap(tmp);
  return *this;
}

void EFalse::swap(EFalse & other)
{

}

EFalse::~EFalse()
{

}

void EFalse::accept(Visitor *v)
{
  v->visitEFalse(this);
}

EFalse *EFalse::clone() const
{
  return new EFalse(*this);
}



/********************   TBool    ********************/
TBool::TBool()
{

}

TBool::TBool(const TBool & other)
{

}

TBool &TBool::operator=(const TBool & other)
{
  TBool tmp(other);
  swap(tmp);
  return *this;
}

void TBool::swap(TBool & other)
{

}

TBool::~TBool()
{

}

void TBool::accept(Visitor *v)
{
  v->visitTBool(this);
}

TBool *TBool::clone() const
{
  return new TBool(*this);
}



/********************   TInt    ********************/
TInt::TInt()
{

}

TInt::TInt(const TInt & other)
{

}

TInt &TInt::operator=(const TInt & other)
{
  TInt tmp(other);
  swap(tmp);
  return *this;
}

void TInt::swap(TInt & other)
{

}

TInt::~TInt()
{

}

void TInt::accept(Visitor *v)
{
  v->visitTInt(this);
}

TInt *TInt::clone() const
{
  return new TInt(*this);
}



/********************   EId    ********************/
EId::EId(PIdentifier *p1)
{
  pidentifier_ = p1;

}

EId::EId(const EId & other)
{
  pidentifier_ = other.pidentifier_->clone();

}

EId &EId::operator=(const EId & other)
{
  EId tmp(other);
  swap(tmp);
  return *this;
}

void EId::swap(EId & other)
{
  std::swap(pidentifier_, other.pidentifier_);

}

EId::~EId()
{
  delete(pidentifier_);

}

void EId::accept(Visitor *v)
{
  v->visitEId(this);
}

EId *EId::clone() const
{
  return new EId(*this);
}



/********************   FParam    ********************/
FParam::FParam(Type *p1, Identifier *p2)
{
  type_ = p1;
  identifier_ = p2;

}

FParam::FParam(const FParam & other)
{
  type_ = other.type_->clone();
  identifier_ = other.identifier_->clone();

}

FParam &FParam::operator=(const FParam & other)
{
  FParam tmp(other);
  swap(tmp);
  return *this;
}

void FParam::swap(FParam & other)
{
  std::swap(type_, other.type_);
  std::swap(identifier_, other.identifier_);

}

FParam::~FParam()
{
  delete(type_);
  delete(identifier_);

}

void FParam::accept(Visitor *v)
{
  v->visitFParam(this);
}

FParam *FParam::clone() const
{
  return new FParam(*this);
}



/********************   BBlock    ********************/
BBlock::BBlock(ListStatement *p1)
{
  liststatement_ = p1;

}

BBlock::BBlock(const BBlock & other)
{
  liststatement_ = other.liststatement_->clone();

}

BBlock &BBlock::operator=(const BBlock & other)
{
  BBlock tmp(other);
  swap(tmp);
  return *this;
}

void BBlock::swap(BBlock & other)
{
  std::swap(liststatement_, other.liststatement_);

}

BBlock::~BBlock()
{
  delete(liststatement_);

}

void BBlock::accept(Visitor *v)
{
  v->visitBBlock(this);
}

BBlock *BBlock::clone() const
{
  return new BBlock(*this);
}



/********************   SVarDec    ********************/
SVarDec::SVarDec(Type *p1, Identifier *p2)
{
  type_ = p1;
  identifier_ = p2;

}

SVarDec::SVarDec(const SVarDec & other)
{
  type_ = other.type_->clone();
  identifier_ = other.identifier_->clone();

}

SVarDec &SVarDec::operator=(const SVarDec & other)
{
  SVarDec tmp(other);
  swap(tmp);
  return *this;
}

void SVarDec::swap(SVarDec & other)
{
  std::swap(type_, other.type_);
  std::swap(identifier_, other.identifier_);

}

SVarDec::~SVarDec()
{
  delete(type_);
  delete(identifier_);

}

void SVarDec::accept(Visitor *v)
{
  v->visitSVarDec(this);
}

SVarDec *SVarDec::clone() const
{
  return new SVarDec(*this);
}



/********************   SBlock    ********************/
SBlock::SBlock(Block *p1)
{
  block_ = p1;

}

SBlock::SBlock(const SBlock & other)
{
  block_ = other.block_->clone();

}

SBlock &SBlock::operator=(const SBlock & other)
{
  SBlock tmp(other);
  swap(tmp);
  return *this;
}

void SBlock::swap(SBlock & other)
{
  std::swap(block_, other.block_);

}

SBlock::~SBlock()
{
  delete(block_);

}

void SBlock::accept(Visitor *v)
{
  v->visitSBlock(this);
}

SBlock *SBlock::clone() const
{
  return new SBlock(*this);
}



/********************   SEmpty    ********************/
SEmpty::SEmpty()
{

}

SEmpty::SEmpty(const SEmpty & other)
{

}

SEmpty &SEmpty::operator=(const SEmpty & other)
{
  SEmpty tmp(other);
  swap(tmp);
  return *this;
}

void SEmpty::swap(SEmpty & other)
{

}

SEmpty::~SEmpty()
{

}

void SEmpty::accept(Visitor *v)
{
  v->visitSEmpty(this);
}

SEmpty *SEmpty::clone() const
{
  return new SEmpty(*this);
}



/********************   SAssign    ********************/
SAssign::SAssign(Assignment *p1)
{
  assignment_ = p1;

}

SAssign::SAssign(const SAssign & other)
{
  assignment_ = other.assignment_->clone();

}

SAssign &SAssign::operator=(const SAssign & other)
{
  SAssign tmp(other);
  swap(tmp);
  return *this;
}

void SAssign::swap(SAssign & other)
{
  std::swap(assignment_, other.assignment_);

}

SAssign::~SAssign()
{
  delete(assignment_);

}

void SAssign::accept(Visitor *v)
{
  v->visitSAssign(this);
}

SAssign *SAssign::clone() const
{
  return new SAssign(*this);
}



/********************   SCall    ********************/
SCall::SCall(FunctionInvocation *p1)
{
  functioninvocation_ = p1;

}

SCall::SCall(const SCall & other)
{
  functioninvocation_ = other.functioninvocation_->clone();

}

SCall &SCall::operator=(const SCall & other)
{
  SCall tmp(other);
  swap(tmp);
  return *this;
}

void SCall::swap(SCall & other)
{
  std::swap(functioninvocation_, other.functioninvocation_);

}

SCall::~SCall()
{
  delete(functioninvocation_);

}

void SCall::accept(Visitor *v)
{
  v->visitSCall(this);
}

SCall *SCall::clone() const
{
  return new SCall(*this);
}



/********************   SBreak    ********************/
SBreak::SBreak()
{

}

SBreak::SBreak(const SBreak & other)
{

}

SBreak &SBreak::operator=(const SBreak & other)
{
  SBreak tmp(other);
  swap(tmp);
  return *this;
}

void SBreak::swap(SBreak & other)
{

}

SBreak::~SBreak()
{

}

void SBreak::accept(Visitor *v)
{
  v->visitSBreak(this);
}

SBreak *SBreak::clone() const
{
  return new SBreak(*this);
}



/********************   SRetExpr    ********************/
SRetExpr::SRetExpr(Expression *p1)
{
  expression_ = p1;

}

SRetExpr::SRetExpr(const SRetExpr & other)
{
  expression_ = other.expression_->clone();

}

SRetExpr &SRetExpr::operator=(const SRetExpr & other)
{
  SRetExpr tmp(other);
  swap(tmp);
  return *this;
}

void SRetExpr::swap(SRetExpr & other)
{
  std::swap(expression_, other.expression_);

}

SRetExpr::~SRetExpr()
{
  delete(expression_);

}

void SRetExpr::accept(Visitor *v)
{
  v->visitSRetExpr(this);
}

SRetExpr *SRetExpr::clone() const
{
  return new SRetExpr(*this);
}



/********************   SRet    ********************/
SRet::SRet()
{

}

SRet::SRet(const SRet & other)
{

}

SRet &SRet::operator=(const SRet & other)
{
  SRet tmp(other);
  swap(tmp);
  return *this;
}

void SRet::swap(SRet & other)
{

}

SRet::~SRet()
{

}

void SRet::accept(Visitor *v)
{
  v->visitSRet(this);
}

SRet *SRet::clone() const
{
  return new SRet(*this);
}



/********************   SIfElse    ********************/
SIfElse::SIfElse(Expression *p1, Statement *p2, Statement *p3)
{
  expression_ = p1;
  statement_1 = p2;
  statement_2 = p3;

}

SIfElse::SIfElse(const SIfElse & other)
{
  expression_ = other.expression_->clone();
  statement_1 = other.statement_1->clone();
  statement_2 = other.statement_2->clone();

}

SIfElse &SIfElse::operator=(const SIfElse & other)
{
  SIfElse tmp(other);
  swap(tmp);
  return *this;
}

void SIfElse::swap(SIfElse & other)
{
  std::swap(expression_, other.expression_);
  std::swap(statement_1, other.statement_1);
  std::swap(statement_2, other.statement_2);

}

SIfElse::~SIfElse()
{
  delete(expression_);
  delete(statement_1);
  delete(statement_2);

}

void SIfElse::accept(Visitor *v)
{
  v->visitSIfElse(this);
}

SIfElse *SIfElse::clone() const
{
  return new SIfElse(*this);
}



/********************   SIf    ********************/
SIf::SIf(Expression *p1, Statement *p2)
{
  expression_ = p1;
  statement_ = p2;

}

SIf::SIf(const SIf & other)
{
  expression_ = other.expression_->clone();
  statement_ = other.statement_->clone();

}

SIf &SIf::operator=(const SIf & other)
{
  SIf tmp(other);
  swap(tmp);
  return *this;
}

void SIf::swap(SIf & other)
{
  std::swap(expression_, other.expression_);
  std::swap(statement_, other.statement_);

}

SIf::~SIf()
{
  delete(expression_);
  delete(statement_);

}

void SIf::accept(Visitor *v)
{
  v->visitSIf(this);
}

SIf *SIf::clone() const
{
  return new SIf(*this);
}



/********************   SWhile    ********************/
SWhile::SWhile(Expression *p1, Statement *p2)
{
  expression_ = p1;
  statement_ = p2;

}

SWhile::SWhile(const SWhile & other)
{
  expression_ = other.expression_->clone();
  statement_ = other.statement_->clone();

}

SWhile &SWhile::operator=(const SWhile & other)
{
  SWhile tmp(other);
  swap(tmp);
  return *this;
}

void SWhile::swap(SWhile & other)
{
  std::swap(expression_, other.expression_);
  std::swap(statement_, other.statement_);

}

SWhile::~SWhile()
{
  delete(expression_);
  delete(statement_);

}

void SWhile::accept(Visitor *v)
{
  v->visitSWhile(this);
}

SWhile *SWhile::clone() const
{
  return new SWhile(*this);
}



/********************   FCall    ********************/
FCall::FCall(Identifier *p1, ListExpression *p2)
{
  identifier_ = p1;
  listexpression_ = p2;

}

FCall::FCall(const FCall & other)
{
  identifier_ = other.identifier_->clone();
  listexpression_ = other.listexpression_->clone();

}

FCall &FCall::operator=(const FCall & other)
{
  FCall tmp(other);
  swap(tmp);
  return *this;
}

void FCall::swap(FCall & other)
{
  std::swap(identifier_, other.identifier_);
  std::swap(listexpression_, other.listexpression_);

}

FCall::~FCall()
{
  delete(identifier_);
  delete(listexpression_);

}

void FCall::accept(Visitor *v)
{
  v->visitFCall(this);
}

FCall *FCall::clone() const
{
  return new FCall(*this);
}



/********************   PLiteral    ********************/
PLiteral::PLiteral(Literal *p1)
{
  literal_ = p1;

}

PLiteral::PLiteral(const PLiteral & other)
{
  literal_ = other.literal_->clone();

}

PLiteral &PLiteral::operator=(const PLiteral & other)
{
  PLiteral tmp(other);
  swap(tmp);
  return *this;
}

void PLiteral::swap(PLiteral & other)
{
  std::swap(literal_, other.literal_);

}

PLiteral::~PLiteral()
{
  delete(literal_);

}

void PLiteral::accept(Visitor *v)
{
  v->visitPLiteral(this);
}

PLiteral *PLiteral::clone() const
{
  return new PLiteral(*this);
}



/********************   PExpr    ********************/
PExpr::PExpr(Expression *p1)
{
  expression_ = p1;

}

PExpr::PExpr(const PExpr & other)
{
  expression_ = other.expression_->clone();

}

PExpr &PExpr::operator=(const PExpr & other)
{
  PExpr tmp(other);
  swap(tmp);
  return *this;
}

void PExpr::swap(PExpr & other)
{
  std::swap(expression_, other.expression_);

}

PExpr::~PExpr()
{
  delete(expression_);

}

void PExpr::accept(Visitor *v)
{
  v->visitPExpr(this);
}

PExpr *PExpr::clone() const
{
  return new PExpr(*this);
}



/********************   PFuncInv    ********************/
PFuncInv::PFuncInv(FunctionInvocation *p1)
{
  functioninvocation_ = p1;

}

PFuncInv::PFuncInv(const PFuncInv & other)
{
  functioninvocation_ = other.functioninvocation_->clone();

}

PFuncInv &PFuncInv::operator=(const PFuncInv & other)
{
  PFuncInv tmp(other);
  swap(tmp);
  return *this;
}

void PFuncInv::swap(PFuncInv & other)
{
  std::swap(functioninvocation_, other.functioninvocation_);

}

PFuncInv::~PFuncInv()
{
  delete(functioninvocation_);

}

void PFuncInv::accept(Visitor *v)
{
  v->visitPFuncInv(this);
}

PFuncInv *PFuncInv::clone() const
{
  return new PFuncInv(*this);
}



/********************   PFExprPrim    ********************/
PFExprPrim::PFExprPrim(Primary *p1)
{
  primary_ = p1;

}

PFExprPrim::PFExprPrim(const PFExprPrim & other)
{
  primary_ = other.primary_->clone();

}

PFExprPrim &PFExprPrim::operator=(const PFExprPrim & other)
{
  PFExprPrim tmp(other);
  swap(tmp);
  return *this;
}

void PFExprPrim::swap(PFExprPrim & other)
{
  std::swap(primary_, other.primary_);

}

PFExprPrim::~PFExprPrim()
{
  delete(primary_);

}

void PFExprPrim::accept(Visitor *v)
{
  v->visitPFExprPrim(this);
}

PFExprPrim *PFExprPrim::clone() const
{
  return new PFExprPrim(*this);
}



/********************   PFExprID    ********************/
PFExprID::PFExprID(Identifier *p1)
{
  identifier_ = p1;

}

PFExprID::PFExprID(const PFExprID & other)
{
  identifier_ = other.identifier_->clone();

}

PFExprID &PFExprID::operator=(const PFExprID & other)
{
  PFExprID tmp(other);
  swap(tmp);
  return *this;
}

void PFExprID::swap(PFExprID & other)
{
  std::swap(identifier_, other.identifier_);

}

PFExprID::~PFExprID()
{
  delete(identifier_);

}

void PFExprID::accept(Visitor *v)
{
  v->visitPFExprID(this);
}

PFExprID *PFExprID::clone() const
{
  return new PFExprID(*this);
}



/********************   UnExpr    ********************/
UnExpr::UnExpr(PostFixExpression *p1)
{
  postfixexpression_ = p1;

}

UnExpr::UnExpr(const UnExpr & other)
{
  postfixexpression_ = other.postfixexpression_->clone();

}

UnExpr &UnExpr::operator=(const UnExpr & other)
{
  UnExpr tmp(other);
  swap(tmp);
  return *this;
}

void UnExpr::swap(UnExpr & other)
{
  std::swap(postfixexpression_, other.postfixexpression_);

}

UnExpr::~UnExpr()
{
  delete(postfixexpression_);

}

void UnExpr::accept(Visitor *v)
{
  v->visitUnExpr(this);
}

UnExpr *UnExpr::clone() const
{
  return new UnExpr(*this);
}



/********************   UnExprMin    ********************/
UnExprMin::UnExprMin(UnaryExpression *p1)
{
  unaryexpression_ = p1;

}

UnExprMin::UnExprMin(const UnExprMin & other)
{
  unaryexpression_ = other.unaryexpression_->clone();

}

UnExprMin &UnExprMin::operator=(const UnExprMin & other)
{
  UnExprMin tmp(other);
  swap(tmp);
  return *this;
}

void UnExprMin::swap(UnExprMin & other)
{
  std::swap(unaryexpression_, other.unaryexpression_);

}

UnExprMin::~UnExprMin()
{
  delete(unaryexpression_);

}

void UnExprMin::accept(Visitor *v)
{
  v->visitUnExprMin(this);
}

UnExprMin *UnExprMin::clone() const
{
  return new UnExprMin(*this);
}



/********************   UnExprNeg    ********************/
UnExprNeg::UnExprNeg(UnaryExpression *p1)
{
  unaryexpression_ = p1;

}

UnExprNeg::UnExprNeg(const UnExprNeg & other)
{
  unaryexpression_ = other.unaryexpression_->clone();

}

UnExprNeg &UnExprNeg::operator=(const UnExprNeg & other)
{
  UnExprNeg tmp(other);
  swap(tmp);
  return *this;
}

void UnExprNeg::swap(UnExprNeg & other)
{
  std::swap(unaryexpression_, other.unaryexpression_);

}

UnExprNeg::~UnExprNeg()
{
  delete(unaryexpression_);

}

void UnExprNeg::accept(Visitor *v)
{
  v->visitUnExprNeg(this);
}

UnExprNeg *UnExprNeg::clone() const
{
  return new UnExprNeg(*this);
}



/********************   MulExpr    ********************/
MulExpr::MulExpr(UnaryExpression *p1)
{
  unaryexpression_ = p1;

}

MulExpr::MulExpr(const MulExpr & other)
{
  unaryexpression_ = other.unaryexpression_->clone();

}

MulExpr &MulExpr::operator=(const MulExpr & other)
{
  MulExpr tmp(other);
  swap(tmp);
  return *this;
}

void MulExpr::swap(MulExpr & other)
{
  std::swap(unaryexpression_, other.unaryexpression_);

}

MulExpr::~MulExpr()
{
  delete(unaryexpression_);

}

void MulExpr::accept(Visitor *v)
{
  v->visitMulExpr(this);
}

MulExpr *MulExpr::clone() const
{
  return new MulExpr(*this);
}



/********************   MulExprMul    ********************/
MulExprMul::MulExprMul(MultiplicativeExpression *p1, UnaryExpression *p2)
{
  multiplicativeexpression_ = p1;
  unaryexpression_ = p2;

}

MulExprMul::MulExprMul(const MulExprMul & other)
{
  multiplicativeexpression_ = other.multiplicativeexpression_->clone();
  unaryexpression_ = other.unaryexpression_->clone();

}

MulExprMul &MulExprMul::operator=(const MulExprMul & other)
{
  MulExprMul tmp(other);
  swap(tmp);
  return *this;
}

void MulExprMul::swap(MulExprMul & other)
{
  std::swap(multiplicativeexpression_, other.multiplicativeexpression_);
  std::swap(unaryexpression_, other.unaryexpression_);

}

MulExprMul::~MulExprMul()
{
  delete(multiplicativeexpression_);
  delete(unaryexpression_);

}

void MulExprMul::accept(Visitor *v)
{
  v->visitMulExprMul(this);
}

MulExprMul *MulExprMul::clone() const
{
  return new MulExprMul(*this);
}



/********************   MulExprDiv    ********************/
MulExprDiv::MulExprDiv(MultiplicativeExpression *p1, UnaryExpression *p2)
{
  multiplicativeexpression_ = p1;
  unaryexpression_ = p2;

}

MulExprDiv::MulExprDiv(const MulExprDiv & other)
{
  multiplicativeexpression_ = other.multiplicativeexpression_->clone();
  unaryexpression_ = other.unaryexpression_->clone();

}

MulExprDiv &MulExprDiv::operator=(const MulExprDiv & other)
{
  MulExprDiv tmp(other);
  swap(tmp);
  return *this;
}

void MulExprDiv::swap(MulExprDiv & other)
{
  std::swap(multiplicativeexpression_, other.multiplicativeexpression_);
  std::swap(unaryexpression_, other.unaryexpression_);

}

MulExprDiv::~MulExprDiv()
{
  delete(multiplicativeexpression_);
  delete(unaryexpression_);

}

void MulExprDiv::accept(Visitor *v)
{
  v->visitMulExprDiv(this);
}

MulExprDiv *MulExprDiv::clone() const
{
  return new MulExprDiv(*this);
}



/********************   MulExprMod    ********************/
MulExprMod::MulExprMod(MultiplicativeExpression *p1, UnaryExpression *p2)
{
  multiplicativeexpression_ = p1;
  unaryexpression_ = p2;

}

MulExprMod::MulExprMod(const MulExprMod & other)
{
  multiplicativeexpression_ = other.multiplicativeexpression_->clone();
  unaryexpression_ = other.unaryexpression_->clone();

}

MulExprMod &MulExprMod::operator=(const MulExprMod & other)
{
  MulExprMod tmp(other);
  swap(tmp);
  return *this;
}

void MulExprMod::swap(MulExprMod & other)
{
  std::swap(multiplicativeexpression_, other.multiplicativeexpression_);
  std::swap(unaryexpression_, other.unaryexpression_);

}

MulExprMod::~MulExprMod()
{
  delete(multiplicativeexpression_);
  delete(unaryexpression_);

}

void MulExprMod::accept(Visitor *v)
{
  v->visitMulExprMod(this);
}

MulExprMod *MulExprMod::clone() const
{
  return new MulExprMod(*this);
}



/********************   AddExpr    ********************/
AddExpr::AddExpr(MultiplicativeExpression *p1)
{
  multiplicativeexpression_ = p1;

}

AddExpr::AddExpr(const AddExpr & other)
{
  multiplicativeexpression_ = other.multiplicativeexpression_->clone();

}

AddExpr &AddExpr::operator=(const AddExpr & other)
{
  AddExpr tmp(other);
  swap(tmp);
  return *this;
}

void AddExpr::swap(AddExpr & other)
{
  std::swap(multiplicativeexpression_, other.multiplicativeexpression_);

}

AddExpr::~AddExpr()
{
  delete(multiplicativeexpression_);

}

void AddExpr::accept(Visitor *v)
{
  v->visitAddExpr(this);
}

AddExpr *AddExpr::clone() const
{
  return new AddExpr(*this);
}



/********************   AddExprAdd    ********************/
AddExprAdd::AddExprAdd(AdditiveExpression *p1, MultiplicativeExpression *p2)
{
  additiveexpression_ = p1;
  multiplicativeexpression_ = p2;

}

AddExprAdd::AddExprAdd(const AddExprAdd & other)
{
  additiveexpression_ = other.additiveexpression_->clone();
  multiplicativeexpression_ = other.multiplicativeexpression_->clone();

}

AddExprAdd &AddExprAdd::operator=(const AddExprAdd & other)
{
  AddExprAdd tmp(other);
  swap(tmp);
  return *this;
}

void AddExprAdd::swap(AddExprAdd & other)
{
  std::swap(additiveexpression_, other.additiveexpression_);
  std::swap(multiplicativeexpression_, other.multiplicativeexpression_);

}

AddExprAdd::~AddExprAdd()
{
  delete(additiveexpression_);
  delete(multiplicativeexpression_);

}

void AddExprAdd::accept(Visitor *v)
{
  v->visitAddExprAdd(this);
}

AddExprAdd *AddExprAdd::clone() const
{
  return new AddExprAdd(*this);
}



/********************   AddExprSub    ********************/
AddExprSub::AddExprSub(AdditiveExpression *p1, MultiplicativeExpression *p2)
{
  additiveexpression_ = p1;
  multiplicativeexpression_ = p2;

}

AddExprSub::AddExprSub(const AddExprSub & other)
{
  additiveexpression_ = other.additiveexpression_->clone();
  multiplicativeexpression_ = other.multiplicativeexpression_->clone();

}

AddExprSub &AddExprSub::operator=(const AddExprSub & other)
{
  AddExprSub tmp(other);
  swap(tmp);
  return *this;
}

void AddExprSub::swap(AddExprSub & other)
{
  std::swap(additiveexpression_, other.additiveexpression_);
  std::swap(multiplicativeexpression_, other.multiplicativeexpression_);

}

AddExprSub::~AddExprSub()
{
  delete(additiveexpression_);
  delete(multiplicativeexpression_);

}

void AddExprSub::accept(Visitor *v)
{
  v->visitAddExprSub(this);
}

AddExprSub *AddExprSub::clone() const
{
  return new AddExprSub(*this);
}



/********************   RelExpr    ********************/
RelExpr::RelExpr(AdditiveExpression *p1)
{
  additiveexpression_ = p1;

}

RelExpr::RelExpr(const RelExpr & other)
{
  additiveexpression_ = other.additiveexpression_->clone();

}

RelExpr &RelExpr::operator=(const RelExpr & other)
{
  RelExpr tmp(other);
  swap(tmp);
  return *this;
}

void RelExpr::swap(RelExpr & other)
{
  std::swap(additiveexpression_, other.additiveexpression_);

}

RelExpr::~RelExpr()
{
  delete(additiveexpression_);

}

void RelExpr::accept(Visitor *v)
{
  v->visitRelExpr(this);
}

RelExpr *RelExpr::clone() const
{
  return new RelExpr(*this);
}



/********************   RelExprLT    ********************/
RelExprLT::RelExprLT(RelationalExpression *p1, AdditiveExpression *p2)
{
  relationalexpression_ = p1;
  additiveexpression_ = p2;

}

RelExprLT::RelExprLT(const RelExprLT & other)
{
  relationalexpression_ = other.relationalexpression_->clone();
  additiveexpression_ = other.additiveexpression_->clone();

}

RelExprLT &RelExprLT::operator=(const RelExprLT & other)
{
  RelExprLT tmp(other);
  swap(tmp);
  return *this;
}

void RelExprLT::swap(RelExprLT & other)
{
  std::swap(relationalexpression_, other.relationalexpression_);
  std::swap(additiveexpression_, other.additiveexpression_);

}

RelExprLT::~RelExprLT()
{
  delete(relationalexpression_);
  delete(additiveexpression_);

}

void RelExprLT::accept(Visitor *v)
{
  v->visitRelExprLT(this);
}

RelExprLT *RelExprLT::clone() const
{
  return new RelExprLT(*this);
}




/********************   RelExprGT    ********************/
RelExprGT::RelExprGT(RelationalExpression *p1, AdditiveExpression *p2)
{
  relationalexpression_ = p1;
  additiveexpression_ = p2;

}

RelExprGT::RelExprGT(const RelExprGT & other)
{
  relationalexpression_ = other.relationalexpression_->clone();
  additiveexpression_ = other.additiveexpression_->clone();

}

RelExprGT &RelExprGT::operator=(const RelExprGT & other)
{
  RelExprGT tmp(other);
  swap(tmp);
  return *this;
}

void RelExprGT::swap(RelExprGT & other)
{
  std::swap(relationalexpression_, other.relationalexpression_);
  std::swap(additiveexpression_, other.additiveexpression_);

}

RelExprGT::~RelExprGT()
{
  delete(relationalexpression_);
  delete(additiveexpression_);

}

void RelExprGT::accept(Visitor *v)
{
  v->visitRelExprGT(this);
}

RelExprGT *RelExprGT::clone() const
{
  return new RelExprGT(*this);
}



/********************   RelExprLE    ********************/
RelExprLE::RelExprLE(RelationalExpression *p1, AdditiveExpression *p2)
{
  relationalexpression_ = p1;
  additiveexpression_ = p2;

}

RelExprLE::RelExprLE(const RelExprLE & other)
{
  relationalexpression_ = other.relationalexpression_->clone();
  additiveexpression_ = other.additiveexpression_->clone();

}

RelExprLE &RelExprLE::operator=(const RelExprLE & other)
{
  RelExprLE tmp(other);
  swap(tmp);
  return *this;
}

void RelExprLE::swap(RelExprLE & other)
{
  std::swap(relationalexpression_, other.relationalexpression_);
  std::swap(additiveexpression_, other.additiveexpression_);

}

RelExprLE::~RelExprLE()
{
  delete(relationalexpression_);
  delete(additiveexpression_);

}

void RelExprLE::accept(Visitor *v)
{
  v->visitRelExprLE(this);
}

RelExprLE *RelExprLE::clone() const
{
  return new RelExprLE(*this);
}



/********************   RelExprGE    ********************/
RelExprGE::RelExprGE(RelationalExpression *p1, AdditiveExpression *p2)
{
  relationalexpression_ = p1;
  additiveexpression_ = p2;

}

RelExprGE::RelExprGE(const RelExprGE & other)
{
  relationalexpression_ = other.relationalexpression_->clone();
  additiveexpression_ = other.additiveexpression_->clone();

}

RelExprGE &RelExprGE::operator=(const RelExprGE & other)
{
  RelExprGE tmp(other);
  swap(tmp);
  return *this;
}

void RelExprGE::swap(RelExprGE & other)
{
  std::swap(relationalexpression_, other.relationalexpression_);
  std::swap(additiveexpression_, other.additiveexpression_);

}

RelExprGE::~RelExprGE()
{
  delete(relationalexpression_);
  delete(additiveexpression_);

}

void RelExprGE::accept(Visitor *v)
{
  v->visitRelExprGE(this);
}

RelExprGE *RelExprGE::clone() const
{
  return new RelExprGE(*this);
}



/********************   EqExpr    ********************/
EqExpr::EqExpr(RelationalExpression *p1)
{
  relationalexpression_ = p1;

}

EqExpr::EqExpr(const EqExpr & other)
{
  relationalexpression_ = other.relationalexpression_->clone();

}

EqExpr &EqExpr::operator=(const EqExpr & other)
{
  EqExpr tmp(other);
  swap(tmp);
  return *this;
}

void EqExpr::swap(EqExpr & other)
{
  std::swap(relationalexpression_, other.relationalexpression_);

}

EqExpr::~EqExpr()
{
  delete(relationalexpression_);

}

void EqExpr::accept(Visitor *v)
{
  v->visitEqExpr(this);
}

EqExpr *EqExpr::clone() const
{
  return new EqExpr(*this);
}



/********************   EqExprEQ    ********************/
EqExprEQ::EqExprEQ(EqualityExpression *p1, RelationalExpression *p2)
{
  equalityexpression_ = p1;
  relationalexpression_ = p2;

}

EqExprEQ::EqExprEQ(const EqExprEQ & other)
{
  equalityexpression_ = other.equalityexpression_->clone();
  relationalexpression_ = other.relationalexpression_->clone();

}

EqExprEQ &EqExprEQ::operator=(const EqExprEQ & other)
{
  EqExprEQ tmp(other);
  swap(tmp);
  return *this;
}

void EqExprEQ::swap(EqExprEQ & other)
{
  std::swap(equalityexpression_, other.equalityexpression_);
  std::swap(relationalexpression_, other.relationalexpression_);

}

EqExprEQ::~EqExprEQ()
{
  delete(equalityexpression_);
  delete(relationalexpression_);

}

void EqExprEQ::accept(Visitor *v)
{
  v->visitEqExprEQ(this);
}

EqExprEQ *EqExprEQ::clone() const
{
  return new EqExprEQ(*this);
}



/********************   EqExprNE    ********************/
EqExprNE::EqExprNE(EqualityExpression *p1, RelationalExpression *p2)
{
  equalityexpression_ = p1;
  relationalexpression_ = p2;

}

EqExprNE::EqExprNE(const EqExprNE & other)
{
  equalityexpression_ = other.equalityexpression_->clone();
  relationalexpression_ = other.relationalexpression_->clone();

}

EqExprNE &EqExprNE::operator=(const EqExprNE & other)
{
  EqExprNE tmp(other);
  swap(tmp);
  return *this;
}

void EqExprNE::swap(EqExprNE & other)
{
  std::swap(equalityexpression_, other.equalityexpression_);
  std::swap(relationalexpression_, other.relationalexpression_);

}

EqExprNE::~EqExprNE()
{
  delete(equalityexpression_);
  delete(relationalexpression_);

}

void EqExprNE::accept(Visitor *v)
{
  v->visitEqExprNE(this);
}

EqExprNE *EqExprNE::clone() const
{
  return new EqExprNE(*this);
}



/********************   CAExpr    ********************/
CAExpr::CAExpr(EqualityExpression *p1)
{
  equalityexpression_ = p1;

}

CAExpr::CAExpr(const CAExpr & other)
{
  equalityexpression_ = other.equalityexpression_->clone();

}

CAExpr &CAExpr::operator=(const CAExpr & other)
{
  CAExpr tmp(other);
  swap(tmp);
  return *this;
}

void CAExpr::swap(CAExpr & other)
{
  std::swap(equalityexpression_, other.equalityexpression_);

}

CAExpr::~CAExpr()
{
  delete(equalityexpression_);

}

void CAExpr::accept(Visitor *v)
{
  v->visitCAExpr(this);
}

CAExpr *CAExpr::clone() const
{
  return new CAExpr(*this);
}



/********************   CAExprAnd    ********************/
CAExprAnd::CAExprAnd(ConditionalAndExpression *p1, EqualityExpression *p2)
{
  conditionalandexpression_ = p1;
  equalityexpression_ = p2;

}

CAExprAnd::CAExprAnd(const CAExprAnd & other)
{
  conditionalandexpression_ = other.conditionalandexpression_->clone();
  equalityexpression_ = other.equalityexpression_->clone();

}

CAExprAnd &CAExprAnd::operator=(const CAExprAnd & other)
{
  CAExprAnd tmp(other);
  swap(tmp);
  return *this;
}

void CAExprAnd::swap(CAExprAnd & other)
{
  std::swap(conditionalandexpression_, other.conditionalandexpression_);
  std::swap(equalityexpression_, other.equalityexpression_);

}

CAExprAnd::~CAExprAnd()
{
  delete(conditionalandexpression_);
  delete(equalityexpression_);

}

void CAExprAnd::accept(Visitor *v)
{
  v->visitCAExprAnd(this);
}

CAExprAnd *CAExprAnd::clone() const
{
  return new CAExprAnd(*this);
}



/********************   COExpr    ********************/
COExpr::COExpr(ConditionalAndExpression *p1)
{
  conditionalandexpression_ = p1;

}

COExpr::COExpr(const COExpr & other)
{
  conditionalandexpression_ = other.conditionalandexpression_->clone();

}

COExpr &COExpr::operator=(const COExpr & other)
{
  COExpr tmp(other);
  swap(tmp);
  return *this;
}

void COExpr::swap(COExpr & other)
{
  std::swap(conditionalandexpression_, other.conditionalandexpression_);

}

COExpr::~COExpr()
{
  delete(conditionalandexpression_);

}

void COExpr::accept(Visitor *v)
{
  v->visitCOExpr(this);
}

COExpr *COExpr::clone() const
{
  return new COExpr(*this);
}



/********************   COExprOr    ********************/
COExprOr::COExprOr(ConditionalOrExpression *p1, ConditionalAndExpression *p2)
{
  conditionalorexpression_ = p1;
  conditionalandexpression_ = p2;

}

COExprOr::COExprOr(const COExprOr & other)
{
  conditionalorexpression_ = other.conditionalorexpression_->clone();
  conditionalandexpression_ = other.conditionalandexpression_->clone();

}

COExprOr &COExprOr::operator=(const COExprOr & other)
{
  COExprOr tmp(other);
  swap(tmp);
  return *this;
}

void COExprOr::swap(COExprOr & other)
{
  std::swap(conditionalorexpression_, other.conditionalorexpression_);
  std::swap(conditionalandexpression_, other.conditionalandexpression_);

}

COExprOr::~COExprOr()
{
  delete(conditionalorexpression_);
  delete(conditionalandexpression_);

}

void COExprOr::accept(Visitor *v)
{
  v->visitCOExprOr(this);
}

COExprOr *COExprOr::clone() const
{
  return new COExprOr(*this);
}



/********************   AssExpr    ********************/
AssExpr::AssExpr(ConditionalOrExpression *p1)
{
  conditionalorexpression_ = p1;

}

AssExpr::AssExpr(const AssExpr & other)
{
  conditionalorexpression_ = other.conditionalorexpression_->clone();

}

AssExpr &AssExpr::operator=(const AssExpr & other)
{
  AssExpr tmp(other);
  swap(tmp);
  return *this;
}

void AssExpr::swap(AssExpr & other)
{
  std::swap(conditionalorexpression_, other.conditionalorexpression_);

}

AssExpr::~AssExpr()
{
  delete(conditionalorexpression_);

}

void AssExpr::accept(Visitor *v)
{
  v->visitAssExpr(this);
}

AssExpr *AssExpr::clone() const
{
  return new AssExpr(*this);
}



/********************   AssExprAss    ********************/
AssExprAss::AssExprAss(Assignment *p1)
{
  assignment_ = p1;

}

AssExprAss::AssExprAss(const AssExprAss & other)
{
  assignment_ = other.assignment_->clone();

}

AssExprAss &AssExprAss::operator=(const AssExprAss & other)
{
  AssExprAss tmp(other);
  swap(tmp);
  return *this;
}

void AssExprAss::swap(AssExprAss & other)
{
  std::swap(assignment_, other.assignment_);

}

AssExprAss::~AssExprAss()
{
  delete(assignment_);

}

void AssExprAss::accept(Visitor *v)
{
  v->visitAssExprAss(this);
}

AssExprAss *AssExprAss::clone() const
{
  return new AssExprAss(*this);
}



/********************   Assign    ********************/
Assign::Assign(Identifier *p1, AssignmentExpression *p2)
{
  identifier_ = p1;
  assignmentexpression_ = p2;

}

Assign::Assign(const Assign & other)
{
  identifier_ = other.identifier_->clone();
  assignmentexpression_ = other.assignmentexpression_->clone();

}

Assign &Assign::operator=(const Assign & other)
{
  Assign tmp(other);
  swap(tmp);
  return *this;
}

void Assign::swap(Assign & other)
{
  std::swap(identifier_, other.identifier_);
  std::swap(assignmentexpression_, other.assignmentexpression_);

}

Assign::~Assign()
{
  delete(identifier_);
  delete(assignmentexpression_);

}

void Assign::accept(Visitor *v)
{
  v->visitAssign(this);
}

Assign *Assign::clone() const
{
  return new Assign(*this);
}



/********************   Expr    ********************/
Expr::Expr(AssignmentExpression *p1)
{
  assignmentexpression_ = p1;

}

Expr::Expr(const Expr & other)
{
  assignmentexpression_ = other.assignmentexpression_->clone();

}

Expr &Expr::operator=(const Expr & other)
{
  Expr tmp(other);
  swap(tmp);
  return *this;
}

void Expr::swap(Expr & other)
{
  std::swap(assignmentexpression_, other.assignmentexpression_);

}

Expr::~Expr()
{
  delete(assignmentexpression_);

}

void Expr::accept(Visitor *v)
{
  v->visitExpr(this);
}

Expr *Expr::clone() const
{
  return new Expr(*this);
}




/********************   ListStatement    ********************/

void ListStatement::accept(Visitor *v)
{
  v->visitListStatement(this);
}


ListStatement *ListStatement::clone() const
{
  return new ListStatement(*this);
}


/********************   ListGlobalDec    ********************/

void ListGlobalDec::accept(Visitor *v)
{
  v->visitListGlobalDec(this);
}


ListGlobalDec *ListGlobalDec::clone() const
{
  return new ListGlobalDec(*this);
}


/********************   ListFormalParam    ********************/

void ListFormalParam::accept(Visitor *v)
{
  v->visitListFormalParam(this);
}


ListFormalParam *ListFormalParam::clone() const
{
  return new ListFormalParam(*this);
}


/********************   ListExpression    ********************/

void ListExpression::accept(Visitor *v)
{
  v->visitListExpression(this);
}


ListExpression *ListExpression::clone() const
{
  return new ListExpression(*this);
}




